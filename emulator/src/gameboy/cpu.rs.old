use super::register;
use super::Bus;
use super::Flag;
use super::Registers;

const IS_DEBUGGING: bool = false;

pub struct CPU {
    registers: Registers,
}

impl CPU {
    pub fn new() -> Self {
        CPU {
            registers: Registers::new(),
        }
    }

    pub fn step(&mut self, bus: &mut Bus) {
        //println!("{:#X}", self.registers.pc);
        let opcode = bus.ram_read_byte(self.registers.pc);
        debug(format!(
            "instruction {:#X}: {:#X}",
            self.registers.pc, opcode
        ));
        self.registers.pc += 1;

        let hex1 = (opcode & 0xF0) << 4;
        let hex2 = opcode & 0x0F;

        match opcode {
            // 16-bit load instructions (LD n, nn)
            0x0 => {}
            0x01 | 0x11 | 0x21 | 0x31 => {
                self.ld_16_n_nn(bus, opcode);
            }
            // 8-bit XOR instructions
            0xAF | 0xA8 | 0xA9 | 0xAA | 0xAB | 0xAC | 0xAD | 0xAE | 0xEE => {
                self.xor_8_n(bus, opcode);
            }
            0x22 => self.ld_into_hl(bus, true),  // LD (HL+)
            0x32 => self.ld_into_hl(bus, false), // LD (HL-)
            0xCB => self.step_cb(bus),           // CB prefix
            0x20 | 0x28 | 0x30 | 0x38 => self.jr_cc_n(bus, opcode), // Jump conditional
            0x06 | 0x0E | 0x16 | 0x1E | 0x26 | 0x2E => self.ld_8_nn_n(bus, opcode), // Load nn, n
            0x7F | 0x78 | 0x79 | 0x7A | 0x7B | 0x7C | 0x7D | 0x0A | 0x1A | 0x7E | 0xFA | 0x3E => {
                self.ld_8_a_n(bus, opcode)
            }
            0xE2 => self.ld_c_a(bus),
            0xC9 => self.stack_return(bus),
            0xC0 | 0xC8 | 0xD0 | 0xD8 => self.ret_cc(bus, opcode),
            0x3C | 0x04 | 0x0C | 0x14 | 0x1C | 0x24 | 0x2C | 0x34 => self.inc_n(bus, opcode),
            0x7F | 0x47 | 0x4F | 0x57 | 0x5F | 0x67 | 0x6F | 0x02 | 0x12 | 0x77 | 0xEA => {
                self.ld_n_a(bus, opcode)
            }
            0xE0 => self.ldh_n_a(bus),
            0xF0 => self.ldh_a_n(bus),
            0xCD => self.call_nn(bus),
            0xF5 | 0xC5 | 0xD5 | 0xE5 => self.push_nn(bus, opcode),
            0x17 => self.rla(bus),
            0xF1 | 0xC1 | 0xD1 | 0xE1 => self.pop_nn(bus, opcode),
            0x3D | 0x05 | 0x0D | 0x15 | 0x1D | 0x25 | 0x2D | 0x35 => self.dec_n(bus, opcode),
            0x03 | 0x13 | 0x23 | 0x33 => self.inc_nn(bus, opcode),
            0x0B | 0x1B | 0x2B | 0x3B => self.dec_nn(bus, opcode),
            0x97 | 0x90 | 0x91 | 0x92 | 0x93 | 0x94 | 0x95 | 0x96 | 0xD6 => self.sub_n(bus, opcode),
            0xC3 => self.jp_nn(bus),
            0x08 => self.jp_nn_sp(bus),
            0x8F | 0x88 | 0x89 | 0x8A | 0x8B | 0x8C | 0x8D | 0x8E | 0xCE => {
                self.adc_a_n(bus, opcode)
            }
            0xC4 | 0xCC | 0xD4 | 0xDC => self.call_cc_nn(bus, opcode),
            0x7F | 0x78 | 0x79 | 0x7A | 0x7B | 0x7C | 0x7D | 0x7E | 0x40 | 0x41 | 0x42 | 0x43
            | 0x44 | 0x45 | 0x46 | 0x48 | 0x49 | 0x4A | 0x4B | 0x4C | 0x4D | 0x4E | 0x50 | 0x51
            | 0x52 | 0x53 | 0x54 | 0x55 | 0x56 | 0x58 | 0x59 | 0x5A | 0x5B | 0x5C | 0x5D | 0x5E
            | 0x60 | 0x61 | 0x62 | 0x63 | 0x64 | 0x65 | 0x66 | 0x68 | 0x69 | 0x6A | 0x6B | 0x6C
            | 0x6D | 0x6E | 0x70 | 0x71 | 0x72 | 0x73 | 0x74 | 0x75 | 0x36 => {
                self.ld_r_r(bus, opcode)
            }
            0xA7 | 0xA0 | 0xA1 | 0xA2 | 0xA3 | 0xA4 | 0xA5 | 0xA6 | 0xE6 => self.and_n(bus, opcode),
            _ => {
                println!("{:?}", self.registers);
                let mut buffer: Vec<u8> = Vec::new();
                buffer.copy_from_slice(&bus.ram.ram[0xA000..0xAFFF]);
                println!("{:?}", buffer);

                panic!(
                    "Instruction {:#X} not supported: {:#X}",
                    self.registers.pc - 1,
                    opcode
                );
            }
        }

        //self.registers.dump();
        debug(format!("{:?}", self.registers));
        //println!("{:#X}: {:#X}", self.registers.pc - 1, opcode);
    }

    fn step_cb(&mut self, bus: &mut Bus) {
        let opcode = bus.ram_read_byte(self.registers.pc);
        debug(format!(
            "CB instruction {:#X}: {:#X}",
            self.registers.pc, opcode
        ));
        self.registers.pc += 1;

        match opcode {
            0x40 | 0x41 | 0x42 | 0x43 | 0x44 | 0x45 | 0x46 | 0x47 | 0x48 | 0x49 | 0x4A | 0x4B
            | 0x4C | 0x4D | 0x4E | 0x4F | 0x50 | 0x51 | 0x52 | 0x53 | 0x54 | 0x55 | 0x56 | 0x57
            | 0x58 | 0x59 | 0x5A | 0x5B | 0x5C | 0x5D | 0x5E | 0x5F | 0x60 | 0x61 | 0x62 | 0x63
            | 0x64 | 0x65 | 0x66 | 0x67 | 0x68 | 0x69 | 0x6A | 0x6B | 0x6C | 0x6D | 0x6E | 0x6F
            | 0x70 | 0x71 | 0x72 | 0x73 | 0x74 | 0x75 | 0x76 | 0x77 | 0x78 | 0x79 | 0x7A | 0x7B
            | 0x7C | 0x7D | 0x7E | 0x7F => self.bit(bus, opcode),
            0x17 | 0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 => self.rl_n(bus, opcode),
            0x07 | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 => self.rlc_n(bus, opcode),
            _ => {
                panic!(
                    "Instruction {:#X} not supported: {:#X}",
                    self.registers.pc - 1,
                    opcode
                );
            }
        }
    }

    // Helper Methods
    fn form_16bit(a: u8, b: u8) -> u16 {
        ((a as u16) << 8) | (b as u16)
    }
    fn read_8bits(&mut self, bus: &Bus) -> u8 {
        let imm1 = bus.ram_read_byte(self.registers.pc);
        self.registers.pc += 1; // Consumed one byte

        imm1
    }
    fn read_16bits(&mut self, bus: &Bus) -> u16 {
        let imm1 = bus.ram_read_byte(self.registers.pc);
        let imm2 = bus.ram_read_byte(self.registers.pc + 1);
        let addr: u16 = CPU::form_16bit(imm2, imm1); // Reverse order due to Big Endian
        self.registers.pc += 2; // Consumed two bytes

        addr
    }

    fn read_ram_hl(&self, bus: &Bus) -> u8 {
        bus.ram_read_byte(self.registers.get_hl())
    }
    fn write_ram_hl(&self, bus: &mut Bus, byte: u8) {
        bus.ram_write_byte(self.registers.get_hl(), byte);
    }

    // Instruction Set
    /// 8-bit load instructions
    fn ld_8_nn_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[LD nn, n (8-bit)]"));
        // LD reg, value
        // Reverse order for Big Endian
        let n = self.read_8bits(bus);

        match opcode {
            0x06 => {
                self.registers.b = n;
            }
            0x0E => {
                self.registers.c = n;
            }
            0x16 => {
                self.registers.d = n;
            }
            0x1E => {
                self.registers.e = n;
            }
            0x26 => {
                self.registers.h = n;
            }
            0x2E => {
                self.registers.l = n;
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn ld_8_a_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[LD a, n (8-bit)]"));
        match opcode {
            0x7F => { /* Nothing */ }
            0x78 => self.registers.a = self.registers.b,
            0x79 => self.registers.a = self.registers.c,
            0x7A => self.registers.a = self.registers.d,
            0x7B => self.registers.a = self.registers.e,
            0x7C => self.registers.a = self.registers.h,
            0x7D => self.registers.a = self.registers.l,
            0x0A => self.registers.a = bus.ram_read_byte(self.registers.get_bc()),
            0x1A => self.registers.a = bus.ram_read_byte(self.registers.get_de()),
            0x7E => self.registers.a = bus.ram_read_byte(self.registers.get_hl()),
            0xFA => self.registers.a = bus.ram_read_byte(self.read_16bits(bus)),
            0x3E => self.registers.a = self.read_8bits(bus),
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn ld_n_a(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[LD n, a]"));
        match opcode {
            0x7F => self.registers.a = self.registers.a,
            0x47 => self.registers.b = self.registers.a,
            0x4F => self.registers.c = self.registers.a,
            0x57 => self.registers.d = self.registers.a,
            0x5F => self.registers.e = self.registers.a,
            0x67 => self.registers.h = self.registers.a,
            0x6F => self.registers.l = self.registers.a,
            0x02 => bus.ram_write_byte(self.registers.get_bc(), self.registers.a),
            0x12 => bus.ram_write_byte(self.registers.get_de(), self.registers.a),
            0x77 => bus.ram_write_byte(self.registers.get_hl(), self.registers.a),
            0xEA => {
                let addr = self.read_16bits(bus);
                bus.ram_write_byte(addr, self.registers.a);
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn ld_c_a(&mut self, bus: &mut Bus) {
        debug(format!("\t[LD c, a]"));
        bus.ram_write_byte(0xFF00 + (self.registers.c as u16), self.registers.a)
        // 0xFF | C
    }

    fn ldh_n_a(&mut self, bus: &mut Bus) {
        debug(format!("\t[LDH n, a]"));
        let byte = self.read_8bits(bus);
        let addr = 0xFF00 + (byte as u16);
        bus.ram_write_byte(addr, self.registers.a);

        //println!("Value at {:#X}: {:#X}", addr, byte);
    }

    fn ldh_a_n(&mut self, bus: &mut Bus) {
        debug(format!("\t[LDH a, n]"));
        let byte = self.read_8bits(bus);
        let addr = 0xFF00 + (byte as u16);
        self.registers.a = bus.ram_read_byte(addr);
    }

    fn ld_r_r(&mut self, bus: &mut Bus, opcode: u8) {
        match opcode {
            0x7F => self.registers.a = self.registers.a,
            0x78 => self.registers.a = self.registers.b,
            0x79 => self.registers.a = self.registers.c,
            0x7A => self.registers.a = self.registers.d,
            0x7B => self.registers.a = self.registers.e,
            0x7C => self.registers.a = self.registers.h,
            0x7D => self.registers.a = self.registers.l,
            0x7E => self.registers.a = self.read_ram_hl(bus),
            0x40 => self.registers.b = self.registers.b,
            0x41 => self.registers.b = self.registers.c,
            0x42 => self.registers.b = self.registers.d,
            0x43 => self.registers.b = self.registers.e,
            0x44 => self.registers.b = self.registers.h,
            0x45 => self.registers.b = self.registers.l,
            0x46 => self.registers.b = self.read_ram_hl(bus),
            0x48 => self.registers.c = self.registers.b,
            0x49 => self.registers.c = self.registers.c,
            0x4A => self.registers.c = self.registers.d,
            0x4B => self.registers.c = self.registers.e,
            0x4C => self.registers.c = self.registers.h,
            0x4D => self.registers.c = self.registers.l,
            0x4E => self.registers.c = self.read_ram_hl(bus),
            0x50 => self.registers.d = self.registers.b,
            0x51 => self.registers.d = self.registers.c,
            0x52 => self.registers.d = self.registers.d,
            0x53 => self.registers.d = self.registers.e,
            0x54 => self.registers.d = self.registers.h,
            0x55 => self.registers.d = self.registers.l,
            0x56 => self.registers.d = self.read_ram_hl(bus),
            0x58 => self.registers.e = self.registers.b,
            0x59 => self.registers.e = self.registers.c,
            0x5A => self.registers.e = self.registers.d,
            0x5B => self.registers.e = self.registers.e,
            0x5C => self.registers.e = self.registers.h,
            0x5D => self.registers.e = self.registers.l,
            0x5E => self.registers.e = self.read_ram_hl(bus),
            0x60 => self.registers.h = self.registers.b,
            0x61 => self.registers.h = self.registers.c,
            0x62 => self.registers.h = self.registers.d,
            0x63 => self.registers.h = self.registers.e,
            0x64 => self.registers.h = self.registers.h,
            0x65 => self.registers.h = self.registers.l,
            0x66 => self.registers.h = self.read_ram_hl(bus),
            0x68 => self.registers.l = self.registers.b,
            0x69 => self.registers.l = self.registers.c,
            0x6A => self.registers.l = self.registers.d,
            0x6B => self.registers.l = self.registers.e,
            0x6C => self.registers.l = self.registers.h,
            0x6D => self.registers.l = self.registers.l,
            0x6E => self.registers.l = self.read_ram_hl(bus),
            0x70 => self.write_ram_hl(bus, self.registers.b),
            0x71 => self.write_ram_hl(bus, self.registers.c),
            0x72 => self.write_ram_hl(bus, self.registers.d),
            0x73 => self.write_ram_hl(bus, self.registers.e),
            0x74 => self.write_ram_hl(bus, self.registers.h),
            0x75 => self.write_ram_hl(bus, self.registers.l),
            0x36 => {
                let byte = self.read_8bits(bus);
                self.write_ram_hl(bus, byte);
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn push_nn(&mut self, bus: &mut Bus, opcode: u8) {
        match opcode {
            0xAF => self.stack_push(bus, self.registers.get_af()),
            0xC5 => self.stack_push(bus, self.registers.get_bc()),
            0xD5 => self.stack_push(bus, self.registers.get_de()),
            0xE5 => self.stack_push(bus, self.registers.get_hl()),
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    // 8-bit ALU

    fn xor_8_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[XOR (8-bit)]"));
        // Modifies FlagsRegister, result of xor => Register A
        let operand: u8;

        match opcode {
            0xAF => operand = self.registers.a,
            0xA8 => operand = self.registers.b,
            0xA9 => operand = self.registers.c,
            0xAA => operand = self.registers.d,
            0xAB => operand = self.registers.e,
            0xAC => operand = self.registers.h,
            0xAD => operand = self.registers.l,
            0xAE => operand = self.read_ram_hl(bus), // 16-bit register destination
            0xEE => operand = self.read_8bits(bus),
            _ => {
                panic!("Unsupported XOR opcode: {:#X}", opcode);
            }
        }

        let result = self.registers.a & operand;
        self.registers.f.set(result == 0, false, false, false);
        self.registers.a = result;
        //self.registers.f.flag(Flag::Z, result == 0);
    }

    fn alu_inc(&mut self, a: u8) -> u8 {
        debug(format!("\t[ALU INC]"));
        let result = a.wrapping_add(1);
        self.registers.f.flag(Flag::Z, result == 0);
        self.registers.f.flag(Flag::N, false);
        self.registers.f.flag(Flag::H, (a & 0xF) == 0xF);

        result
    }

    fn alu_dec(&mut self, a: u8) -> u8 {
        debug(format!("\t[ALU DEC]"));
        let result = a.wrapping_sub(1);
        self.registers.f.flag(Flag::Z, result == 0);
        self.registers.f.flag(Flag::N, true);
        self.registers.f.flag(Flag::H, (a & 0x0F) == 0);

        result
    }

    fn alu_add(&mut self, a: u8, n: u8, use_carry: bool) -> u8 {
        debug(format!("\t[ALU ADD]"));
        let result = a.wrapping_add(n);
        let c = if use_carry && self.registers.f.carry {
            1
        } else {
            0
        };

        self.registers.f.flag(Flag::Z, result == 0);
        self.registers.f.flag(Flag::N, true);
        self.registers
            .f
            .flag(Flag::H, (a & 0xF) + (n & 0xF) + c > 0xF);
        self.registers
            .f
            .flag(Flag::C, (a as u16) + (n as u16) + (c as u16) > 0xFF);

        result
    }

    fn alu_sub(&mut self, a: u8, n: u8, use_carry: bool) -> u8 {
        debug(format!("\t[ALU SUB]"));
        let result = a.wrapping_sub(n);
        let c = if use_carry && self.registers.f.carry {
            1
        } else {
            0
        };

        self.registers.f.flag(Flag::Z, result == 0);
        self.registers.f.flag(Flag::N, true);
        self.registers.f.flag(Flag::H, (a & 0x0F) < (n & 0x0F) + c);
        self.registers
            .f
            .flag(Flag::C, (a as u16) < (n as u16) + (c as u16));

        result
    }

    fn sub_n(&mut self, bus: &mut Bus, opcode: u8) {
        let a = self.registers.a;

        match opcode {
            0x97 => self.registers.a = self.alu_sub(a, self.registers.a, false),
            0x90 => self.registers.a = self.alu_sub(a, self.registers.b, false),
            0x91 => self.registers.a = self.alu_sub(a, self.registers.c, false),
            0x92 => self.registers.a = self.alu_sub(a, self.registers.d, false),
            0x93 => self.registers.a = self.alu_sub(a, self.registers.e, false),
            0x94 => self.registers.a = self.alu_sub(a, self.registers.h, false),
            0x95 => self.registers.a = self.alu_sub(a, self.registers.l, false),
            0x96 => {
                let mut byte = self.read_ram_hl(bus);
                byte = self.alu_sub(a, byte, false);
                self.registers.a = byte;
            }
            0xD6 => {
                let mut byte = self.read_8bits(bus);
                byte = self.alu_sub(a, byte, false);
                self.registers.a = byte;
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn inc_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[INC 1]"));
        match opcode {
            0x3C => self.registers.a = self.alu_inc(self.registers.a),
            0x04 => self.registers.b = self.alu_inc(self.registers.b),
            0x0C => self.registers.c = self.alu_inc(self.registers.c),
            0x14 => self.registers.d = self.alu_inc(self.registers.d),
            0x1C => self.registers.e = self.alu_inc(self.registers.e),
            0x24 => self.registers.h = self.alu_inc(self.registers.h),
            0x2C => self.registers.l = self.alu_inc(self.registers.l),
            0x34 => {
                let mut byte: u8 = self.read_ram_hl(bus);
                byte = self.alu_inc(byte);
                self.write_ram_hl(bus, byte);
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn dec_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[DEC n]"));
        match opcode {
            0x3D => self.registers.a = self.alu_dec(self.registers.a),
            0x05 => self.registers.b = self.alu_dec(self.registers.b),
            0x0D => self.registers.c = self.alu_dec(self.registers.c),
            0x15 => self.registers.d = self.alu_dec(self.registers.d),
            0x1D => self.registers.e = self.alu_dec(self.registers.e),
            0x25 => self.registers.h = self.alu_dec(self.registers.h),
            0x2D => self.registers.l = self.alu_dec(self.registers.l),
            0x35 => {
                let mut byte: u8 = self.read_ram_hl(bus);
                byte = self.alu_dec(byte);
                self.write_ram_hl(bus, byte);
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn adc_a_n(&mut self, bus: &mut Bus, opcode: u8) {
        match opcode {
            0x8F => self.registers.a = self.alu_add(self.registers.a, self.registers.a, true),
            0x88 => self.registers.a = self.alu_add(self.registers.a, self.registers.b, true),
            0x89 => self.registers.a = self.alu_add(self.registers.a, self.registers.c, true),
            0x8A => self.registers.a = self.alu_add(self.registers.a, self.registers.d, true),
            0x8B => self.registers.a = self.alu_add(self.registers.a, self.registers.e, true),
            0x8C => self.registers.a = self.alu_add(self.registers.a, self.registers.h, true),
            0x8D => self.registers.a = self.alu_add(self.registers.a, self.registers.l, true),
            0x8E => self.registers.a = self.alu_add(self.registers.a, self.read_ram_hl(bus), true),
            0xCE => {
                let byte = self.read_8bits(bus);
                self.registers.a = self.alu_add(self.registers.a, byte, true)
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn alu_and(&mut self, a: u8, b: u8) -> u8 {
        let result = a & b;
        self.registers.f.set(result == 0, false, true, false);

        result
    }

    fn and_n(&mut self, bus: &mut Bus, opcode: u8) {
        let a = self.registers.a;

        match opcode {
            0xA7 => self.registers.a = self.alu_and(a, self.registers.a),
            0xA0 => self.registers.a = self.alu_and(a, self.registers.b),
            0xA1 => self.registers.a = self.alu_and(a, self.registers.c),
            0xA2 => self.registers.a = self.alu_and(a, self.registers.d),
            0xA3 => self.registers.a = self.alu_and(a, self.registers.e),
            0xA4 => self.registers.a = self.alu_and(a, self.registers.h),
            0xA5 => self.registers.a = self.alu_and(a, self.registers.l),
            0xA6 => self.registers.a = self.alu_and(a, self.read_ram_hl(bus)),
            0xE6 => {
                let byte = self.read_8bits(bus);
                self.registers.a = self.alu_and(a, byte);
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    /// 16-bit load instructions
    fn ld_16_n_nn(&mut self, bus: &Bus, opcode: u8) {
        debug(format!("\t[LD n, nn (16-bit)]"));
        let value: u16 = self.read_16bits(bus);
        debug(format!("\tvalue: {:#X}", value));

        match opcode {
            0x01 => self.registers.set_bc(value),
            0x11 => self.registers.set_de(value),
            0x21 => self.registers.set_hl(value),
            0x31 => self.registers.sp = value,
            _ => {
                panic!("Unsupported nn for {:#X}", opcode)
            }
        }
    }

    fn ld_from_hl(&mut self, bus: &mut Bus, inc: bool) {
        debug(format!("\t[LD from HL]"));
        self.registers.a = self.read_ram_hl(bus);
        self._modify_hl(inc);
    }
    fn ld_into_hl(&mut self, bus: &mut Bus, inc: bool) {
        debug(format!("\t[LD into HL]"));
        self.write_ram_hl(bus, self.registers.a);
        self._modify_hl(inc);
    }

    fn _modify_hl(&mut self, inc: bool) {
        let mut hl = self.registers.get_hl();
        if inc {
            hl = hl + 1;
        } else {
            hl = hl - 1;
        }

        self.registers.set_hl(hl);
    }

    /// 16-bit ALU
    fn alu_inc_16(&mut self, a: u16) -> u16 {
        debug(format!("\t[ALU INC 16]"));
        let result = a.wrapping_add(1);
        self.registers.f.flag(Flag::Z, result == 0);
        self.registers.f.flag(Flag::N, false);
        self.registers.f.flag(Flag::H, (a & 0xF) == 0xF);

        result
    }

    fn alu_dec_16(&mut self, a: u16) -> u16 {
        debug(format!("\t[ALU DEC 16]"));
        let result = a.wrapping_sub(1);
        self.registers.f.flag(Flag::Z, result == 0);
        self.registers.f.flag(Flag::N, true);
        self.registers.f.flag(Flag::H, (a & 0x0F) == 0);

        result
    }

    fn inc_nn(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[INC n 16-bit]"));
        match opcode {
            0x03 => {
                let value = self.registers.get_bc();
                let new_value = self.alu_inc_16(value);
                self.registers.set_bc(new_value);
            }
            0x13 => {
                let value = self.registers.get_de();
                let new_value = self.alu_inc_16(value);
                self.registers.set_bc(new_value);
            }
            0x23 => {
                let value = self.registers.get_hl();
                let new_value = self.alu_inc_16(value);
                self.registers.set_bc(new_value);
            }
            0x33 => self.registers.sp = self.alu_inc_16(self.registers.sp),
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn dec_nn(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[DEC n 16-bit]"));
        match opcode {
            0x0B => {
                let value = self.registers.get_bc();
                let new_value = self.alu_dec_16(value);
                self.registers.set_bc(new_value);
            }
            0x1B => {
                let value = self.registers.get_de();
                let new_value = self.alu_dec_16(value);
                self.registers.set_bc(new_value);
            }
            0x2B => {
                let value = self.registers.get_hl();
                let new_value = self.alu_dec_16(value);
                self.registers.set_bc(new_value);
            }
            0x3B => self.registers.sp = self.alu_dec_16(self.registers.sp),
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    // Bit Opcodes
    fn bit(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[BIT]"));
        let hex1: u8 = (opcode & 0xF0) >> 4;

        // operand
        let operand: u8;
        match hex1 {
            0x7 | 0xF => operand = self.registers.a,
            0x0 | 0x8 => operand = self.registers.b,
            0x1 | 0x9 => operand = self.registers.c,
            0x2 | 0xA => operand = self.registers.d,
            0x3 | 0xB => operand = self.registers.e,
            0x4 | 0xC => operand = self.registers.h,
            0x5 | 0xD => operand = self.registers.l,
            0x6 | 0xE => operand = self.read_ram_hl(bus), // 16-bit register destination
            _ => operand = self.registers.a,              // This fall-through should never occur
        }

        // b
        let b: u8;
        if 0x40 <= operand && operand <= 0x47 {
            b = 0;
        } else if 0x48 <= operand && operand <= 0x4F {
            b = 1;
        } else if 0x50 <= operand && operand <= 0x57 {
            b = 2;
        } else if 0x58 <= operand && operand <= 0x5F {
            b = 3;
        } else if 0x60 <= operand && operand <= 0x67 {
            b = 4;
        } else if 0x68 <= operand && operand <= 0x6F {
            b = 5;
        } else if 0x70 <= operand && operand <= 0x7F {
            b = 6;
        } else {
            b = 7;
        }

        debug(format!("\tb: {:#X}", b));
        let mask = 1 << b;
        let result = operand & mask;
        self.registers.f.flag(Flag::Z, result == 0);
        self.registers.f.flag(Flag::N, false);
        self.registers.f.flag(Flag::H, true);
    }

    // Jump instructions
    fn jr_cc_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[JR cc n]"));
        let n = self.read_8bits(bus) as i8;
        debug(format!("\tn: {:#X}", n));
        // let cc = self.read_8bits(bus);
        //debug("\tcc: {:#X}", cc);

        let mut jump = false;

        match opcode {
            0x20 => {
                if !self.registers.f.zero {
                    jump = true
                }
            }
            0x28 => {
                if self.registers.f.zero {
                    jump = true
                }
            }
            0x30 => {
                if !self.registers.f.carry {
                    jump = true
                }
            }
            0x38 => {
                if self.registers.f.carry {
                    jump = true
                }
            }
            _ => {}
        }

        if jump {
            debug(format!("\t[Jumping!]"));
            self.jump_relative(n);
        // TODO: perform safe adding?
        } else {
            debug(format!("\t[NOT Jumping]"));
        }
    }

    fn jump_relative(&mut self, n: i8) {
        self.registers.pc = ((self.registers.pc as u32 as i32) + (n as i32)) as u16;
    }

    // Stack/Returns
    fn stack_pop(&mut self, bus: &mut Bus) -> u16 {
        let word = bus.ram_read_word(self.registers.sp);
        self.registers.sp = self.registers.sp.wrapping_add(2);
        debug(format!("POPPING: {:#X}", word));

        word
    }

    fn stack_push(&mut self, bus: &mut Bus, word: u16) {
        self.registers.sp = self.registers.sp.wrapping_sub(2);
        bus.ram_write_word(self.registers.sp, word);
        debug(format!("PUSHING: {:#X}", word));
    }

    fn stack_return(&mut self, bus: &mut Bus) {
        debug(format!("\t[stack return]"));
        let addr = self.stack_pop(bus);
        self.registers.pc = addr;
    }

    pub fn ret_cc(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[ret cc]"));
        let mut jump = false;

        match opcode {
            0xC0 => {
                if !self.registers.f.zero {
                    jump = true
                }
            }
            0xC8 => {
                if self.registers.f.zero {
                    jump = true
                }
            }
            0xD0 => {
                if !self.registers.f.carry {
                    jump = true
                }
            }
            0xD8 => {
                if self.registers.f.carry {
                    jump = true
                }
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }

        if jump {
            self.stack_return(bus);
        }
    }

    fn pop_nn(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[POP nn]"));
        let word = self.stack_pop(bus);
        match opcode {
            0xF1 => self.registers.set_af(word),
            0xC1 => self.registers.set_bc(word),
            0xD1 => self.registers.set_de(word),
            0xE1 => self.registers.set_hl(word),
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn jp_nn(&mut self, bus: &mut Bus) {
        let addr = self.read_16bits(bus);
        self.registers.pc = addr;
    }

    fn jp_nn_sp(&mut self, bus: &mut Bus) {
        let addr = self.read_16bits(bus);
        bus.ram_write_word(addr, self.registers.sp);
    }

    // Calls
    fn call_nn(&mut self, bus: &mut Bus) {
        debug(format!("\t[call cc]"));
        self.stack_push(bus, self.registers.pc - 1);

        let word = self.read_16bits(bus);
        self.registers.pc = word;
    }

    fn call_cc_nn(&mut self, bus: &mut Bus, opcode: u8) {
        let mut jump: bool = false;

        match opcode {
            0xC4 => {
                if !self.registers.f.zero {
                    jump = true
                }
            }
            0xCC => {
                if self.registers.f.zero {
                    jump = true
                }
            }
            0xD4 => {
                if !self.registers.f.carry {
                    jump = true
                }
            }
            0xDC => {
                if self.registers.f.carry {
                    jump = true
                }
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }

        if jump {
            self.call_nn(bus);
        }
    }

    // Rotates & Shifts
    fn rl_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[rl n]"));

        match opcode {
            0x17 => self.registers.a = self.rl_through(self.registers.a),
            0x10 => self.registers.b = self.rl_through(self.registers.a),
            0x11 => self.registers.c = self.rl_through(self.registers.a),
            0x12 => self.registers.d = self.rl_through(self.registers.a),
            0x13 => self.registers.e = self.rl_through(self.registers.a),
            0x14 => self.registers.h = self.rl_through(self.registers.a),
            0x15 => self.registers.l = self.rl_through(self.registers.a),
            0x16 => {
                let byte = self.read_ram_hl(bus);
                let new_byte = self.rl_through(byte);
                self.write_ram_hl(bus, new_byte);
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn rlc_n(&mut self, bus: &mut Bus, opcode: u8) {
        debug(format!("\t[rlc n]"));
        match opcode {
            0x07 => self.registers.a = self.rl_through(self.registers.a),
            0x00 => self.registers.b = self.rl_through(self.registers.a),
            0x01 => self.registers.c = self.rl_through(self.registers.a),
            0x02 => self.registers.d = self.rl_through(self.registers.a),
            0x03 => self.registers.e = self.rl_through(self.registers.a),
            0x04 => self.registers.h = self.rl_through(self.registers.a),
            0x05 => self.registers.l = self.rl_through(self.registers.a),
            0x06 => {
                let byte = self.read_ram_hl(bus);
                let new_byte = self.rl_circular(byte);
                self.write_ram_hl(bus, new_byte);
            }
            _ => {
                panic!("Not implemented: {:#X}", opcode);
            }
        }
    }

    fn rla(&mut self, bus: &mut Bus) {
        debug(format!("\t[RLA]"));
        self.registers.a = self.rl_through(self.registers.a)
    }

    fn rl_through(&mut self, byte: u8) -> u8 {
        let msb = (byte & 0b1000000) >> 7;
        let lsb = self.registers.f.carry;
        // self.registers.f.flag(Flag::C, msb == 1);
        let mut new_byte = byte;
        new_byte >>= 1;
        new_byte |= lsb as u8;

        self.registers.f.set(new_byte == 0, false, false, msb == 0);

        new_byte
    }

    fn rl_circular(&mut self, byte: u8) -> u8 {
        let msb = (byte & 0b1000000) >> 7;
        self.registers.f.flag(Flag::C, msb == 1);

        let mut new_byte = byte;
        new_byte >>= 1;
        new_byte |= msb as u8;

        new_byte
    }
}

fn debug(msg: String) {
    if IS_DEBUGGING {
        println!("{}", msg);
    }
}
